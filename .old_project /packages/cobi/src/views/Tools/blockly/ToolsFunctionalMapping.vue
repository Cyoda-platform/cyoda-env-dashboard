<template>
  <div class="tools-functional-mapping">
    <div v-loading="isLoadingBlockly" :style="{ height: `${blocklyHeight}px` }" class="blocklyDiv" ref="blocklyDivRef"></div>
  </div>
</template>

<script setup lang="ts">
import { usePlatformMappingStore } from "../../../stores/platform-mapping";
import { ref, onBeforeUnmount } from "vue";

import * as Blockly from "blockly/core";

import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/FunctionalMappingConfig";
import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/Expresssions";
import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementVariables";
import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementReturn";
import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementSetDstValue";
import "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/Functions";
import GeneratedFunctions from "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedFunctions";
import GeneratedTransformers from "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedTransformers";

import JSONGenerator from "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/generators/json_generator.js";
import BlocklyGenerator from "../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/generators/blockly_generator";
import type { EntityMappingConfigDto, FunctionalMappingConfigDto, MappingConfigDto } from "../../../components/DataMapper/MappingConfigDto";
import { XMLBuilder, XMLParser } from "fast-xml-parser";
import HelperFormat from "@cyoda/ui-lib/src/helpers/HelperFormat";
import HelperMapper from "../../../helpers/HelperMapper";

const props = defineProps({
  blocklyHeight: {
    default: 450
  }
});
const platformMappingStore = usePlatformMappingStore();
function getListAllFunctions() {
  return platformMappingStore.getListAllFunctions();
}

function getListAllTransformers() {
  return platformMappingStore.getListAllTransformers();
}

function getListAllDictionaries() {
  return platformMappingStore.getListAllDictionaries();
}
const blocklyDivRef = ref(null);

const code = ref<string>("");
const workspace = ref(null);
const generator = ref(null);
let options = ref({
  grid: {
    spacing: 25,
    length: 3,
    colour: "#ccc"
  },
  zoom: {
    controls: true
  }
});

const isLoadingBlockly = ref<boolean>(false);
let listAllFunctions = ref([]);
let listAllTransformers = ref([]);
let listAllDictionaries = ref([]);

async function initAllFunctions() {
  const { data } = await getListAllFunctions();
  listAllFunctions.value = data;
  GeneratedFunctions.init(listAllFunctions.value);
}

async function initListTransformers() {
  const { data } = await getListAllTransformers();
  listAllTransformers.value = data;
  GeneratedTransformers.init(listAllTransformers.value, workspace.value);
}

async function initListAllDictionaries() {
  const { data } = await getListAllDictionaries();
  listAllDictionaries.value = data.dictionaries;
}

onBeforeUnmount(() => {
  workspace.value?.clear();
});

function addBlockly() {
  JSONGenerator.vue = this;

  workspace.value = Blockly.inject(blocklyDivRef.value, options.value);
}

function setContentToBlockly(dataMapping: MappingConfigDto, entityMapping: EntityMappingConfigDto, functionalMapping: FunctionalMappingConfigDto) {
  workspace.value.clear();
  JSONGenerator.vue.functionalMappingConfig = functionalMapping;
  const existStatements = HelperMapper.clearAutoGeneratedFields(functionalMapping.statements);
  Blockly.Xml.domToWorkspace(Blockly.utils.xml.textToDom(getXmlForBlockly(dataMapping, entityMapping, functionalMapping)), workspace.value);
  let jsonDataGenerated = JSONGenerator.workspaceToCode(workspace.value);
  if (jsonDataGenerated) {
    jsonDataGenerated = parseJson(jsonDataGenerated);
    const generatedStatements = jsonDataGenerated.statements;
    return {
      existStatements,
      generatedStatements
    };
  }
  return {
    existStatements: {},
    generatedStatements: {}
  };
}

function parseJson(json) {
  return JSON.parse(json.replace(/\\([dwsb<>AZ])/gi, "\\\\$1"));
}
function getXmlForBlockly(dataMapping: MappingConfigDto, entityMapping: EntityMappingConfigDto, functionalMapping: FunctionalMappingConfigDto) {
  const dataMappingConfigDto = dataMapping;
  const selectedEntityMapping = entityMapping;
  selectedEntityMapping.functionalMappings = [functionalMapping];
  dataMappingConfigDto.entityMappings = [selectedEntityMapping];

  const generator = new BlocklyGenerator();
  generator.setAllFunctions(listAllFunctions.value);
  generator.setAllTransformers(listAllTransformers.value);
  generator.setAllDictionaries(listAllDictionaries.value);
  generator.setMappingConfigDto(dataMappingConfigDto);

  const result = generator.transform();
  let blocklyXml: any = Object.values(result)[0];
  return fixErrorWithDuplicateVariables(blocklyXml);
}

function fixErrorWithDuplicateVariables(content) {
  const dataXmlObj = parseXml(content);
  const duplacateNames = {};
  if (!dataXmlObj.xml.variables) return content;

  const varaiables = Array.isArray(dataXmlObj.xml.variables.variable) ? dataXmlObj.xml.variables.variable : [dataXmlObj.xml.variables.variable];
  varaiables.forEach((variable) => {
    const name = variable["#text"];
    const id = variable["@_id"];
    if (duplacateNames[name] === undefined) {
      duplacateNames[name] = [id];
    } else {
      duplacateNames[name].push(id);
    }
  });

  let isWasDuplicateVariables = false;

  Object.values(duplacateNames).forEach((ids: string[]) => {
    if (ids.length > 1) {
      ids.forEach((id, index) => {
        if (index > 0) {
          content.replaceAll(id, ids[0]);
          dataXmlObj.xml.variables.variable = dataXmlObj.xml.variables.variable.filter((el) => el["@_id"] !== id);
          isWasDuplicateVariables = true;
        }
      });
    }
  });

  if (isWasDuplicateVariables) {
    const dataXmlObjTmp = parseXml(content);
    dataXmlObjTmp.xml.variables.variable = dataXmlObj.xml.variables.variable;
    return buildXml(dataXmlObjTmp);
  }
  return content;
}

function parseXml(dataXml: string) {
  const parserXml = new XMLParser({
    ignoreAttributes: false,
    numberParseOptions: {
      leadingZeros: false,
      hex: false
    }
  });
  return parserXml.parse(dataXml);
}

function buildXml(dataXmlObj) {
  const builderXml = new XMLBuilder({
    ignoreAttributes: false
  });
  return builderXml.build(dataXmlObj);
}

function shortNamePath(name: string) {
  return HelperFormat.shortNamePath(name);
}

defineExpose({ code, workspace, generator, initAllFunctions, initListTransformers, initListAllDictionaries, addBlockly, setContentToBlockly });
</script>
