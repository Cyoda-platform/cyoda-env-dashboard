import React, { useState, useEffect, useRef } from 'react';
import { Modal, Form, Input, Button, Select, Space, Divider, Alert, Tag, Tabs, Upload, message } from 'antd';
import {
  PlusOutlined,
  DeleteOutlined,
  CodeOutlined,
  BlockOutlined,
  UploadOutlined,
  DownloadOutlined,
  QuestionCircleOutlined,
  SearchOutlined,
  ReloadOutlined
} from '@ant-design/icons';
import * as Blockly from 'blockly/core';
import FileSaver from 'file-saver';
import { XMLBuilder, XMLParser } from 'fast-xml-parser';
import CodeEditor from '../CodeEditor';
import type { FunctionalMappingConfigDto, EntityMappingConfigDto, MappingConfigDto } from '../../types';
import './FunctionalMappingSettings.css';

// Import Blockly blocks
import './FunctionalMappingSettings/FunctionalMapping/blocks/FunctionalMappingConfig';
import './FunctionalMappingSettings/FunctionalMapping/blocks/Expresssions';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementVariables';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementReturn';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementSetDstValue';
import './FunctionalMappingSettings/FunctionalMapping/blocks/Functions';
import GeneratedFunctions from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedFunctions';
import GeneratedTransformers from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedTransformers';
import GeneratedDictionaries from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedDictionaries';

// Import generators
import JSONGenerator from './FunctionalMappingSettings/FunctionalMapping/generators/json_generator.js';
import BlocklyGenerator from './FunctionalMappingSettings/FunctionalMapping/generators/blockly_generator';

// Import helpers
import { clearAutoGeneratedFields } from '../../utils/mapperHelper';
import { useDataMappingApi } from '../../api/dataMappingApi';

// Import new components
import VariableDialog, { VariableDialogRef } from './FunctionalMappingSettings/VariableDialog';
import FunctionalMappingSearch from './FunctionalMappingSettings/FunctionalMappingSearch';
import CodeDisplay from './FunctionalMappingSettings/CodeDisplay';
import FunctionDescriptionDialog, { FunctionDescriptionDialogRef } from './FunctionalMappingSettings/FunctionDescriptionDialog';
import FunctionalMappingDiff, { FunctionalMappingDiffRef } from './FunctionalMappingSettings/FunctionalMappingDiff';

interface FunctionalMappingSettingsProps {
  visible: boolean;
  functionalMapping: FunctionalMappingConfigDto | null;
  entityMapping: EntityMappingConfigDto | null;
  dataMappingConfig: MappingConfigDto | null;
  sourceData?: any;
  availableSourcePaths?: string[];
  onSave: (functionalMapping: FunctionalMappingConfigDto) => void;
  onCancel: () => void;
}

const FunctionalMappingSettings: React.FC<FunctionalMappingSettingsProps> = ({
  visible,
  functionalMapping,
  entityMapping,
  dataMappingConfig,
  availableSourcePaths = [],
  onSave,
  onCancel,
}) => {
  const [form] = Form.useForm();
  const [localMapping, setLocalMapping] = useState<FunctionalMappingConfigDto | null>(null);
  const [codeEditorVisible, setCodeEditorVisible] = useState(false);
  const [currentStatementIndex, setCurrentStatementIndex] = useState<number>(-1);
  const [currentStatementCode, setCurrentStatementCode] = useState<string>('');
  const [activeTab, setActiveTab] = useState<string>('blockly');
  const [generatedCode, setGeneratedCode] = useState<string>('');
  const [isLoadingBlockly, setIsLoadingBlockly] = useState(false);
  const [errorBlocklyNonExistent, setErrorBlocklyNonExistent] = useState(false);
  const [searchKey, setSearchKey] = useState(0);

  const blocklyDivRef = useRef<HTMLDivElement>(null);
  const workspaceRef = useRef<any>(null);
  const listAllFunctionsRef = useRef<any[]>([]);
  const listAllTransformersRef = useRef<any[]>([]);
  const listAllDictionariesRef = useRef<any[]>([]);
  const variableDialogRef = useRef<VariableDialogRef>(null);
  const functionDescriptionDialogRef = useRef<FunctionDescriptionDialogRef>(null);
  const functionalMappingDiffRef = useRef<FunctionalMappingDiffRef>(null);

  const { getListAllFunctions, getListAllTransformers, getListAllDictionaries } = useDataMappingApi();

  // Initialize Blockly workspace
  useEffect(() => {
    if (visible && blocklyDivRef.current && !workspaceRef.current) {
      const options = {
        grid: {
          spacing: 25,
          length: 3,
          colour: '#ccc',
        },
        zoom: {
          controls: true,
        },
      };

      (JSONGenerator as any).vue = { functionalMappingConfig: null };
      workspaceRef.current = Blockly.inject(blocklyDivRef.current, options);

      // Add change listener to update code
      workspaceRef.current.addChangeListener(() => {
        updateGeneratedCode();
      });

      // Load data
      loadBlocklyData();
    }

    return () => {
      if (workspaceRef.current && !visible) {
        workspaceRef.current.dispose();
        workspaceRef.current = null;
      }
    };
  }, [visible]);

  useEffect(() => {
    if (functionalMapping) {
      setLocalMapping({ ...functionalMapping });
      form.setFieldsValue({
        name: functionalMapping.name,
        dstPath: functionalMapping.dstPath,
        srcPaths: functionalMapping.srcPaths,
      });

      // Load into Blockly if workspace is ready
      if (workspaceRef.current && dataMappingConfig && entityMapping) {
        loadFunctionalMappingIntoBlockly(functionalMapping);
      }
    }
  }, [functionalMapping, form, dataMappingConfig, entityMapping]);

  // Load Blockly data (functions, transformers, dictionaries)
  const loadBlocklyData = async () => {
    setIsLoadingBlockly(true);
    try {
      // Load functions
      const { data: functions } = await getListAllFunctions();
      listAllFunctionsRef.current = functions;
      GeneratedFunctions.init(functions);

      // Load transformers
      const { data: transformers } = await getListAllTransformers();
      listAllTransformersRef.current = transformers;
      GeneratedTransformers.init(transformers, workspaceRef.current);

      // Load dictionaries
      const { data: dictionaries } = await getListAllDictionaries();
      listAllDictionariesRef.current = dictionaries.dictionaries;
      GeneratedDictionaries.init(dictionaries.dictionaries);
    } catch (error) {
      console.error('Failed to load Blockly data:', error);
    } finally {
      setIsLoadingBlockly(false);
    }
  };

  // Load functional mapping into Blockly
  const loadFunctionalMappingIntoBlockly = (fm: FunctionalMappingConfigDto) => {
    if (!workspaceRef.current || !dataMappingConfig || !entityMapping) return;

    try {
      workspaceRef.current.clear();
      (JSONGenerator as any).vue.functionalMappingConfig = fm;

      // Create a copy of the data mapping config with only this functional mapping
      const dataMappingCopy = JSON.parse(JSON.stringify(dataMappingConfig));
      const entityMappingCopy = JSON.parse(JSON.stringify(entityMapping));
      entityMappingCopy.functionalMappings = [fm];
      dataMappingCopy.entityMappings = [entityMappingCopy];

      // Create generator and set data
      const generator = new BlocklyGenerator();
      generator.setAllFunctions(listAllFunctionsRef.current);
      generator.setAllTransformers(listAllTransformersRef.current);
      generator.setAllDictionaries(listAllDictionariesRef.current);
      generator.setMappingConfigDto(dataMappingCopy);

      // Generate XML
      const result = generator.transform();
      let blocklyXml: any = Object.values(result)[0];

      // Load into workspace
      const dom = Blockly.utils.xml.textToDom(blocklyXml);
      Blockly.Xml.domToWorkspace(dom, workspaceRef.current);

      updateGeneratedCode();
    } catch (error) {
      console.error('Failed to load functional mapping into Blockly:', error);
    }
  };

  // Update generated code from Blockly
  const updateGeneratedCode = () => {
    if (!workspaceRef.current) return;

    try {
      const code = (JSONGenerator as any).workspaceToCode(workspaceRef.current);
      setGeneratedCode(code);

      // Parse and update statements
      if (localMapping && code) {
        const parsed = JSON.parse(code);
        const statements = clearAutoGeneratedFields(parsed.statements || []);
        setLocalMapping({
          ...localMapping,
          statements,
        });
      }
    } catch (error) {
      console.error('Failed to generate code:', error);
    }
  };

  // Toolbar action handlers
  const handleAddVariable = () => {
    variableDialogRef.current?.open();
  };

  const handleSaveVariable = (name: string) => {
    if (workspaceRef.current) {
      workspaceRef.current.createVariable(name);
      message.success(`Variable "${name}" created`);
    }
  };

  const handleExportXML = () => {
    if (!workspaceRef.current) return;

    try {
      const xml = Blockly.Xml.workspaceToDom(workspaceRef.current);
      const xmlText = Blockly.Xml.domToText(xml);

      const builder = new XMLBuilder({ format: true });
      const parser = new XMLParser();
      const xmlObj = parser.parse(xmlText);
      const formattedXml = builder.build(xmlObj);

      const blob = new Blob([formattedXml], { type: 'text/xml;charset=utf-8' });
      FileSaver.saveAs(blob, `functional-mapping-${localMapping?.dstPath || 'export'}.xml`);
      message.success('XML exported successfully');
    } catch (error) {
      console.error('Failed to export XML:', error);
      message.error('Failed to export XML');
    }
  };

  const handleImportXML = (file: any) => {
    if (!workspaceRef.current) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const xmlText = e.target?.result as string;
        const dom = Blockly.utils.xml.textToDom(xmlText);
        workspaceRef.current.clear();
        Blockly.Xml.domToWorkspace(dom, workspaceRef.current);
        message.success('XML imported successfully');
      } catch (error) {
        console.error('Failed to import XML:', error);
        message.error('Failed to import XML');
      }
    };
    reader.readAsText(file);
    return false; // Prevent upload
  };

  const handleOpenFunctionDescription = () => {
    functionDescriptionDialogRef.current?.open();
  };

  const handleSearchChange = (value: any) => {
    console.log('Search selected:', value);
    // TODO: Add block to workspace based on selection
    setSearchKey(searchKey + 1);
  };

  const handleRegenerateBlockly = () => {
    if (functionalMapping) {
      loadFunctionalMappingIntoBlockly(functionalMapping);
      setErrorBlocklyNonExistent(false);
      message.success('Blocks regenerated');
    }
  };

  const handleRegenerateBlocklyAll = () => {
    // TODO: Implement regenerate all blocks
    handleRegenerateBlockly();
  };

  const handleSave = async () => {
    try {
      await form.validateFields();

      // Get statements from Blockly
      if (workspaceRef.current && localMapping) {
        const code = (JSONGenerator as any).workspaceToCode(workspaceRef.current);
        if (code) {
          const parsed = JSON.parse(code);
          const statements = clearAutoGeneratedFields(parsed.statements || []);

          const updatedMapping = {
            ...localMapping,
            statements,
          };

          onSave(updatedMapping);
        } else {
          onSave(localMapping);
        }
      } else if (localMapping) {
        onSave(localMapping);
      }
    } catch (error) {
      console.error('Validation failed:', error);
    }
  };

  const handleAddSourcePath = (path: string) => {
    if (localMapping && !localMapping.srcPaths.includes(path)) {
      const updated = {
        ...localMapping,
        srcPaths: [...localMapping.srcPaths, path],
      };
      setLocalMapping(updated);
      form.setFieldsValue({ srcPaths: updated.srcPaths });
    }
  };

  const handleRemoveSourcePath = (path: string) => {
    if (localMapping) {
      const updated = {
        ...localMapping,
        srcPaths: localMapping.srcPaths.filter((p) => p !== path),
      };
      setLocalMapping(updated);
      form.setFieldsValue({ srcPaths: updated.srcPaths });
    }
  };

  const handleAddStatement = () => {
    if (localMapping) {
      const newStatement: any = {
        type: 'RETURN' as const,
        expression: {
          type: 'CONSTANT',
          constantSource: 'INPUT' as const,
          args: [],
        },
        collectElemsSetModes: [],
      };
      const updated = {
        ...localMapping,
        statements: [...localMapping.statements, newStatement],
      };
      setLocalMapping(updated);
    }
  };

  const handleEditStatement = (index: number) => {
    setCurrentStatementIndex(index);
    // Convert statement object to JSON for editing
    const statement = localMapping?.statements[index];
    setCurrentStatementCode(statement ? JSON.stringify(statement, null, 2) : '');
    setCodeEditorVisible(true);
  };

  const handleDeleteStatement = (index: number) => {
    if (localMapping) {
      const updated = {
        ...localMapping,
        statements: localMapping.statements.filter((_, i) => i !== index),
      };
      setLocalMapping(updated);
    }
  };

  const handleSaveCode = (code: string) => {
    if (localMapping && currentStatementIndex >= 0) {
      try {
        const parsed = JSON.parse(code);
        const updated = { ...localMapping };
        updated.statements[currentStatementIndex] = parsed;
        setLocalMapping(updated);
        setCodeEditorVisible(false);
        setCurrentStatementIndex(-1);
      } catch (error) {
        console.error('Invalid JSON:', error);
      }
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (localMapping) {
      setLocalMapping({
        ...localMapping,
        name: e.target.value || null,
      });
    }
  };

  if (!localMapping) return null;

  const getStatementPreview = (statement: any): string => {
    return JSON.stringify(statement, null, 2).substring(0, 100);
  };

  return (
    <>
      <Modal
        title="Functional Mapping Settings"
        open={visible}
        onOk={handleSave}
        onCancel={onCancel}
        width={900}
        className="functional-mapping-settings-modal"
      >
        <div className="functional-mapping-settings">
          <Form form={form} layout="vertical">
            <Form.Item
              label="Name"
              name="name"
              help="If you do not fill this field, it will be generated automatically"
            >
              <Input
                placeholder="Optional name for this mapping"
                onChange={handleNameChange}
              />
            </Form.Item>

            <Form.Item
              label="Target Path"
              name="dstPath"
              rules={[{ required: true, message: 'Please enter target path' }]}
            >
              <Input disabled />
            </Form.Item>

            <Divider>Source Paths</Divider>

            <Form.Item label="Selected Source Paths">
              <div className="source-paths-list">
                {localMapping.srcPaths.length === 0 ? (
                  <Alert
                    message="No source paths selected"
                    description="Add source paths to use in your functional mapping"
                    type="info"
                    showIcon
                  />
                ) : (
                  <Space wrap>
                    {localMapping.srcPaths.map((path) => (
                      <Tag
                        key={path}
                        closable
                        onClose={() => handleRemoveSourcePath(path)}
                      >
                        {path}
                      </Tag>
                    ))}
                  </Space>
                )}
              </div>
            </Form.Item>

            <Form.Item label="Add Source Path">
              <Select
                placeholder="Select a source path to add"
                onChange={handleAddSourcePath}
                value={undefined}
                showSearch
                filterOption={(input, option) =>
                  (option?.label ?? '').toLowerCase().includes(input.toLowerCase())
                }
                options={availableSourcePaths
                  .filter((path) => !localMapping.srcPaths.includes(path))
                  .map((path) => ({
                    label: path,
                    value: path,
                  }))}
              />
            </Form.Item>

            <Divider>Transformation Logic</Divider>

            <Tabs
              activeKey={activeTab}
              onChange={setActiveTab}
              items={[
                {
                  key: 'blockly',
                  label: (
                    <span>
                      <BlockOutlined /> Visual Editor (Blockly)
                    </span>
                  ),
                  children: (
                    <div className="blockly-editor-section">
                      {errorBlocklyNonExistent ? (
                        <div className="blockly-error-section">
                          <Alert
                            message="Warning"
                            description="Error with Non Existent parameters. Recommended to re-generate this block or all blocks"
                            type="warning"
                            showIcon
                            style={{ marginBottom: 16 }}
                          />
                          <Space>
                            <Button onClick={handleRegenerateBlockly}>
                              <ReloadOutlined /> Regenerate current
                            </Button>
                            <Button onClick={handleRegenerateBlocklyAll}>
                              <ReloadOutlined /> Regenerate all blocks
                            </Button>
                          </Space>
                        </div>
                      ) : (
                        <>
                          <div className="blockly-toolbar">
                            <Space wrap>
                              <FunctionalMappingSearch
                                key={searchKey}
                                listAllFunctions={listAllFunctionsRef.current}
                                listAllTransformers={listAllTransformersRef.current}
                                onChange={handleSearchChange}
                              />
                              <Button type="default" onClick={handleAddVariable} icon={<PlusOutlined />}>
                                Add Variable
                              </Button>
                              <Button type="primary" onClick={handleExportXML} icon={<DownloadOutlined />}>
                                Export XML
                              </Button>
                              <Upload
                                accept=".xml"
                                beforeUpload={handleImportXML}
                                showUploadList={false}
                              >
                                <Button type="default" icon={<UploadOutlined />}>
                                  Import XML
                                </Button>
                              </Upload>
                              <Button type="default" onClick={handleOpenFunctionDescription} icon={<QuestionCircleOutlined />}>
                                Documentation
                              </Button>
                            </Space>
                          </div>
                          <div
                            ref={blocklyDivRef}
                            className="blockly-workspace"
                            style={{
                              height: '450px',
                              width: '100%',
                              border: '1px solid #d9d9d9',
                              borderRadius: '4px',
                              marginTop: '16px'
                            }}
                          />
                          <CodeDisplay code={generatedCode ? JSON.stringify(JSON.parse(generatedCode), null, 2) : ''} />
                        </>
                      )}
                      {isLoadingBlockly && (
                        <div style={{
                          position: 'absolute',
                          top: '50%',
                          left: '50%',
                          transform: 'translate(-50%, -50%)',
                          zIndex: 1000
                        }}>
                          <Alert message="Loading Blockly editor..." type="info" showIcon />
                        </div>
                      )}
                    </div>
                  ),
                },
                {
                  key: 'code',
                  label: (
                    <span>
                      <CodeOutlined /> Generated Code
                    </span>
                  ),
                  children: (
                    <div className="code-preview-section">
                      <Alert
                        message="Generated JSON"
                        description="This code is automatically generated from the Blockly blocks above."
                        type="success"
                        showIcon
                        style={{ marginBottom: 16 }}
                      />
                      <pre style={{
                        background: '#f5f5f5',
                        padding: '16px',
                        borderRadius: '4px',
                        maxHeight: '450px',
                        overflow: 'auto',
                        fontSize: '12px',
                      }}>
                        {generatedCode ? JSON.stringify(JSON.parse(generatedCode), null, 2) : '// No code generated yet'}
                      </pre>
                    </div>
                  ),
                },
                {
                  key: 'manual',
                  label: (
                    <span>
                      <CodeOutlined /> Manual JSON Editor
                    </span>
                  ),
                  children: (
                    <div className="statements-section">
                      {localMapping.statements.length === 0 ? (
                        <Alert
                          message="No statements defined"
                          description="Use the Visual Editor (Blockly) tab to create transformations, or add statements manually here."
                          type="info"
                          showIcon
                          style={{ marginBottom: 16 }}
                        />
                      ) : (
                        <div className="statements-list">
                          {localMapping.statements.map((statement, index) => (
                            <div key={index} className="statement-item">
                              <div className="statement-header">
                                <span className="statement-label">Statement {index + 1}</span>
                                <Space>
                                  <Button
                                    type="text"
                                    icon={<CodeOutlined />}
                                    onClick={() => handleEditStatement(index)}
                                  >
                                    Edit
                                  </Button>
                                  <Button
                                    type="text"
                                    danger
                                    icon={<DeleteOutlined />}
                                    onClick={() => handleDeleteStatement(index)}
                                  >
                                    Delete
                                  </Button>
                                </Space>
                              </div>
                              <pre className="statement-preview">
                                {getStatementPreview(statement)}
                                {JSON.stringify(statement).length > 100 ? '...' : ''}
                              </pre>
                            </div>
                          ))}
                        </div>
                      )}

                      <Button
                        type="primary"
                        icon={<PlusOutlined />}
                        onClick={handleAddStatement}
                        style={{ marginTop: 16 }}
                      >
                        Add Statement
                      </Button>
                    </div>
                  ),
                },
              ]}
            />
          </Form>

          <Divider />

          <Alert
            message="Functional Mapping Info"
            description="Functional mappings allow you to use multiple source paths and custom JavaScript/Groovy code to transform data before mapping it to the target."
            type="info"
            showIcon
          />
        </div>
      </Modal>

      <Modal
        title={`Edit Statement ${currentStatementIndex + 1}`}
        open={codeEditorVisible}
        onOk={() => handleSaveCode(currentStatementCode)}
        onCancel={() => {
          setCodeEditorVisible(false);
          setCurrentStatementIndex(-1);
        }}
        width={1000}
        className="code-editor-modal"
      >
        <Alert
          message="Edit Statement JSON"
          description="Edit the statement configuration as JSON. Make sure the JSON is valid before saving."
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
        />
        <CodeEditor
          value={currentStatementCode}
          onChange={(value) => setCurrentStatementCode(value || '')}
          language="json"
          height="500px"
        />
      </Modal>

      {/* Helper Dialogs */}
      <VariableDialog ref={variableDialogRef} onAdd={handleSaveVariable} />
      <FunctionDescriptionDialog
        ref={functionDescriptionDialogRef}
        listAllFunctions={listAllFunctionsRef.current}
        listAllTransformers={listAllTransformersRef.current}
      />
      <FunctionalMappingDiff ref={functionalMappingDiffRef} />
    </>
  );
};

export default FunctionalMappingSettings;

