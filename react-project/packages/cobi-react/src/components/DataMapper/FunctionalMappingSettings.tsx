import React, { useState, useEffect, useRef } from 'react';
import { Modal, Form, Input, Button, Select, Space, Divider, Alert, Tag, Tabs, Upload, message } from 'antd';
import {
  PlusOutlined,
  DeleteOutlined,
  CodeOutlined,
  BlockOutlined,
  UploadOutlined,
  DownloadOutlined,
  QuestionCircleOutlined,
  ReloadOutlined
} from '@ant-design/icons';
import * as Blockly from 'blockly/core';
import * as En from 'blockly/msg/en';
import FileSaver from 'file-saver';
import { XMLBuilder, XMLParser } from 'fast-xml-parser';
import CodeEditor from '../CodeEditor';
import type { FunctionalMappingConfigDto, EntityMappingConfigDto, MappingConfigDto } from '../../types';
import './FunctionalMappingSettings.css';

// Import Blockly blocks
import './FunctionalMappingSettings/FunctionalMapping/blocks/FunctionalMappingConfig';
import './FunctionalMappingSettings/FunctionalMapping/blocks/Expresssions';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementVariables';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementReturn';
import './FunctionalMappingSettings/FunctionalMapping/blocks/StatementSetDstValue';
import './FunctionalMappingSettings/FunctionalMapping/blocks/Functions';
import GeneratedFunctions from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedFunctions';
import GeneratedTransformers from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedTransformers';
import GeneratedDictionaries from './FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedDictionaries';

// Import custom fields
import './FunctionalMappingSettings/FunctionalMapping/fields/field_dst_path.js';

// Import generators
import JSONGenerator from './FunctionalMappingSettings/FunctionalMapping/generators/json_generator.js';
import BlocklyGenerator from './FunctionalMappingSettings/FunctionalMapping/generators/blockly_generator';

// Import helpers
import { clearAutoGeneratedFields } from '../../utils/mapperHelper';
import { useDataMappingApi } from '../../api/dataMappingApi';
import HelperFunctionalMapping from '../../utils/functionalMappingHelper';

// Import new components
import VariableDialog, { VariableDialogRef } from './FunctionalMappingSettings/VariableDialog';
import FunctionalMappingSearch from './FunctionalMappingSettings/FunctionalMappingSearch';
import CodeDisplay from './FunctionalMappingSettings/CodeDisplay';
import FunctionDescriptionDialog, { FunctionDescriptionDialogRef } from './FunctionalMappingSettings/FunctionDescriptionDialog';
import FunctionalMappingDiff, { FunctionalMappingDiffRef } from './FunctionalMappingSettings/FunctionalMappingDiff';

interface FunctionalMappingSettingsProps {
  visible: boolean;
  functionalMapping: FunctionalMappingConfigDto | null;
  entityMapping: EntityMappingConfigDto | null;
  dataMappingConfig: MappingConfigDto | null;
  sourceData?: any;
  availableSourcePaths?: string[];
  onSave: (functionalMapping: FunctionalMappingConfigDto) => void;
  onCancel: () => void;
}

const FunctionalMappingSettings: React.FC<FunctionalMappingSettingsProps> = ({
  visible,
  functionalMapping,
  entityMapping,
  dataMappingConfig,
  availableSourcePaths = [],
  onSave,
  onCancel,
}) => {
  const [form] = Form.useForm();
  const [localMapping, setLocalMapping] = useState<FunctionalMappingConfigDto | null>(null);
  const [codeEditorVisible, setCodeEditorVisible] = useState(false);
  const [currentStatementIndex, setCurrentStatementIndex] = useState<number>(-1);
  const [currentStatementCode, setCurrentStatementCode] = useState<string>('');
  const [activeTab, setActiveTab] = useState<string>('blockly');
  const [generatedCode, setGeneratedCode] = useState<string>('');
  const [isLoadingBlockly, setIsLoadingBlockly] = useState(false);
  const [errorBlocklyNonExistent, setErrorBlocklyNonExistent] = useState(false);
  const [searchKey, setSearchKey] = useState(0);

  const blocklyDivRef = useRef<HTMLDivElement>(null);
  const workspaceRef = useRef<any>(null);
  const listAllFunctionsRef = useRef<any[]>([]);
  const listAllTransformersRef = useRef<any[]>([]);
  const listAllDictionariesRef = useRef<any[]>([]);
  const variableDialogRef = useRef<VariableDialogRef>(null);
  const functionDescriptionDialogRef = useRef<FunctionDescriptionDialogRef>(null);
  const functionalMappingDiffRef = useRef<FunctionalMappingDiffRef>(null);

  const { getListAllFunctions, getListAllTransformers, getListAllDictionaries } = useDataMappingApi();

  // Get toolbox configuration
  const getToolbox = () => {
    const statements = HelperFunctionalMapping.getStatements();
    const expressions = HelperFunctionalMapping.getExpressions();
    const functionsGrouped = HelperFunctionalMapping.getFunctions(listAllFunctionsRef.current || []);
    const transformersGrouped = HelperFunctionalMapping.getTransformers(listAllTransformersRef.current || []);

    const contents: any[] = [
      {
        kind: 'category',
        name: 'Statements',
        colour: '#5c80a6',
        contents: statements.map((statement) => ({
          kind: 'block',
          type: statement.value,
        })),
      },
      {
        kind: 'category',
        name: 'Expressions',
        colour: '#5ba55b',
        contents: expressions.map((expression) => ({
          kind: 'block',
          type: expression.value,
        })),
      },
    ];

    // Add transformers if available
    if (Object.keys(transformersGrouped).length > 0) {
      contents.push({
        kind: 'category',
        name: 'Transformers',
        colour: '#a5745b',
        contents: Object.keys(transformersGrouped).map((type) => ({
          kind: 'category',
          name: type,
          contents: transformersGrouped[type].map((transformer: string) => ({
            kind: 'block',
            type: transformer,
          })),
        })),
      });
    }

    // Add functions if available
    if (Object.keys(functionsGrouped).length > 0) {
      contents.push({
        kind: 'category',
        name: 'Functions',
        colour: '#a55b80',
        contents: Object.keys(functionsGrouped).map((type) => ({
          kind: 'category',
          name: type,
          contents: functionsGrouped[type].map((funcName: string) => ({
            kind: 'block',
            type: funcName,
          })),
        })),
      });
    }

    // Add dictionaries if available
    if (listAllDictionariesRef.current && listAllDictionariesRef.current.length > 0) {
      contents.push({
        kind: 'category',
        name: 'Dropdown expressions',
        colour: '#5b68a5',
        contents: listAllDictionariesRef.current.map((dictionary: any) => ({
          kind: 'category',
          name: dictionary.provider,
          contents: dictionary.entries.map((entry: any) => ({
            kind: 'block',
            type: HelperFunctionalMapping.getDictionaryName(dictionary, entry),
          })),
        })),
      });
    }

    return {
      kind: 'categoryToolbox',
      contents,
    };
  };

  // Initialize Blockly workspace
  useEffect(() => {
    if (visible && blocklyDivRef.current && !workspaceRef.current) {
      console.log('[Blockly] Initializing workspace...');

      // Set Blockly locale
      Blockly.setLocale(En);

      const options: any = {
        grid: {
          spacing: 25,
          length: 3,
          colour: '#ccc',
        },
        zoom: {
          controls: true,
        },
        toolbox: getToolbox(),
      };

      console.log('[Blockly] Toolbox configuration:', options.toolbox);

      // Initialize JSONGenerator.vue with callbacks
      (JSONGenerator as any).vue = {
        functionalMappingConfig: functionalMapping,
        onOpenDialogModellingPopUp: (inst: any) => {
          console.log('[Blockly] onOpenDialogModellingPopUp called', inst);
          // TODO: Implement entity field selector
        },
        onOpenDialogSetModesOptions: (field: any) => {
          console.log('[Blockly] onOpenDialogSetModesOptions called', field);
          // TODO: Implement set modes dialog
        },
      };

      workspaceRef.current = Blockly.inject(blocklyDivRef.current, options);
      console.log('[Blockly] Workspace injected:', workspaceRef.current);

      // Register custom context menu items
      try {
        Blockly.ContextMenuRegistry.registry.register({
          displayText: 'Copy Block',
          preconditionFn: () => 'enabled',
          callback: (scope: any) => {
            const dataDom = Blockly.Xml.blockToDom(scope.block, true);
            const dataText = Blockly.Xml.domToText(dataDom);
            localStorage.setItem('BLOCKLY_COPY_KEY', dataText);
            message.success('Block copied');
          },
          scopeType: Blockly.ContextMenuRegistry.ScopeType.BLOCK,
          id: 'copy',
          weight: 100,
        });

        Blockly.ContextMenuRegistry.registry.register({
          displayText: 'Paste Block',
          preconditionFn: () => {
            return localStorage.getItem('BLOCKLY_COPY_KEY') ? 'enabled' : 'disabled';
          },
          callback: (scope: any) => {
            const rawData = localStorage.getItem('BLOCKLY_COPY_KEY');
            if (rawData) {
              const dom = Blockly.utils.xml.textToDom(rawData);
              const block = Blockly.Xml.domToBlock(dom, scope.workspace);
              block.moveBy(20, 20);
              message.success('Block pasted');
            }
          },
          scopeType: Blockly.ContextMenuRegistry.ScopeType.WORKSPACE,
          id: 'paste',
          weight: 100,
        });

        Blockly.ContextMenuRegistry.registry.register({
          displayText: 'Help',
          preconditionFn: (scope: any) => {
            return scope.block.type.indexOf('function_') > -1 || scope.block.type.indexOf('transformer_') > -1
              ? 'enabled'
              : 'hidden';
          },
          callback: (scope: any) => {
            console.log('[Blockly] Help requested for block:', scope.block.type);
            message.info('Help feature coming soon');
          },
          scopeType: Blockly.ContextMenuRegistry.ScopeType.BLOCK,
          id: 'cobi_help',
          weight: 101,
        });

        console.log('[Blockly] Context menu items registered');
      } catch (error) {
        console.error('[Blockly] Failed to register context menu items:', error);
      }

      // Disable flyout auto-close
      if (workspaceRef.current.toolbox && workspaceRef.current.toolbox.flyout) {
        workspaceRef.current.toolbox.flyout.autoClose = false;
        console.log('[Blockly] Flyout auto-close disabled');
      }

      // Add change listener to update code
      workspaceRef.current.addChangeListener(() => {
        updateGeneratedCode();
      });

      // Load data
      loadBlocklyData();
    }

    return () => {
      if (workspaceRef.current && !visible) {
        console.log('[Blockly] Disposing workspace');

        // Unregister context menu items
        try {
          Blockly.ContextMenuRegistry.registry.unregister('copy');
          Blockly.ContextMenuRegistry.registry.unregister('paste');
          Blockly.ContextMenuRegistry.registry.unregister('cobi_help');
        } catch (error) {
          console.error('[Blockly] Failed to unregister context menu items:', error);
        }

        workspaceRef.current.dispose();
        workspaceRef.current = null;
      }
    };
  }, [visible]);

  useEffect(() => {
    if (functionalMapping) {
      setLocalMapping({ ...functionalMapping });
      form.setFieldsValue({
        name: functionalMapping.name,
        dstPath: functionalMapping.dstPath,
        srcPaths: functionalMapping.srcPaths,
      });

      // Load into Blockly if workspace is ready
      if (workspaceRef.current && dataMappingConfig && entityMapping) {
        loadFunctionalMappingIntoBlockly(functionalMapping);
      }
    }
  }, [functionalMapping, form, dataMappingConfig, entityMapping]);

  // Load Blockly data (functions, transformers, dictionaries)
  const loadBlocklyData = async () => {
    setIsLoadingBlockly(true);
    try {
      console.log('[Blockly] Loading functions, transformers, and dictionaries...');

      // Load functions
      const { data: functions } = await getListAllFunctions();
      listAllFunctionsRef.current = functions;
      GeneratedFunctions.init(functions);
      console.log('[Blockly] Loaded functions:', functions?.length || 0);

      // Load transformers
      const { data: transformers } = await getListAllTransformers();
      listAllTransformersRef.current = transformers;
      GeneratedTransformers.init(transformers, workspaceRef.current);
      console.log('[Blockly] Loaded transformers:', transformers?.length || 0);

      // Load dictionaries
      const { data: dictionaries } = await getListAllDictionaries();
      listAllDictionariesRef.current = dictionaries.dictionaries;
      GeneratedDictionaries.init(dictionaries.dictionaries);
      console.log('[Blockly] Loaded dictionaries:', dictionaries.dictionaries?.length || 0);

      // Update toolbox after data is loaded
      if (workspaceRef.current) {
        workspaceRef.current.updateToolbox(getToolbox());
        console.log('[Blockly] Toolbox updated');
      }
    } catch (error) {
      console.error('[Blockly] Failed to load Blockly data:', error);
    } finally {
      setIsLoadingBlockly(false);
    }
  };

  // Load functional mapping into Blockly
  const loadFunctionalMappingIntoBlockly = (fm: FunctionalMappingConfigDto) => {
    console.log('[Blockly] loadFunctionalMappingIntoBlockly called', {
      hasWorkspace: !!workspaceRef.current,
      hasDataMappingConfig: !!dataMappingConfig,
      hasEntityMapping: !!entityMapping,
      fm
    });

    if (!workspaceRef.current) {
      console.warn('[Blockly] Cannot load: workspace not initialized');
      return;
    }
    if (!dataMappingConfig) {
      console.warn('[Blockly] Cannot load: dataMappingConfig not available');
      return;
    }
    if (!entityMapping) {
      console.warn('[Blockly] Cannot load: entityMapping not available');
      return;
    }

    try {
      console.log('[Blockly] Clearing workspace and loading blocks...');
      workspaceRef.current.clear();
      (JSONGenerator as any).vue.functionalMappingConfig = fm;

      // Create a copy of the data mapping config with only this functional mapping
      const dataMappingCopy = JSON.parse(JSON.stringify(dataMappingConfig));
      const entityMappingCopy = JSON.parse(JSON.stringify(entityMapping));
      entityMappingCopy.functionalMappings = [fm];
      dataMappingCopy.entityMappings = [entityMappingCopy];

      console.log('[Blockly] Creating BlocklyGenerator...');
      // Create generator and set data
      const generator = new BlocklyGenerator();
      generator.setAllFunctions(listAllFunctionsRef.current || []);
      generator.setAllTransformers(listAllTransformersRef.current || []);
      generator.setAllDictionaries(listAllDictionariesRef.current || []);
      generator.setMappingConfigDto(dataMappingCopy);

      // Generate XML
      console.log('[Blockly] Generating XML from functional mapping...');
      const result = generator.transform();
      let blocklyXml: any = Object.values(result)[0];
      console.log('[Blockly] Generated XML:', blocklyXml);

      // Load into workspace
      console.log('[Blockly] Loading XML into workspace...');
      const dom = Blockly.utils.xml.textToDom(blocklyXml);
      Blockly.Xml.domToWorkspace(dom, workspaceRef.current);
      console.log('[Blockly] Blocks loaded successfully!');

      updateGeneratedCode();
    } catch (error: any) {
      console.error('[Blockly] Failed to load functional mapping into Blockly:', error);

      if (error.message && error.message.indexOf('Unknown block type') > -1) {
        console.error('[Blockly] Unknown block type detected');
        message.error('Some block types are not recognized');
      } else if (error.message && (error.message.indexOf('Ignoring non-existent') > -1 || error.message.indexOf('is already in use') > -1)) {
        console.error('[Blockly] Non-existent parameters or duplicate IDs detected');
        setErrorBlocklyNonExistent(true);
      }
    }
  };

  // Update generated code from Blockly
  const updateGeneratedCode = () => {
    if (!workspaceRef.current) return;

    try {
      const code = (JSONGenerator as any).workspaceToCode(workspaceRef.current);
      setGeneratedCode(code);

      // Parse and update statements
      if (localMapping && code) {
        const parsed = JSON.parse(code);
        const statements = clearAutoGeneratedFields(parsed.statements || []);
        setLocalMapping({
          ...localMapping,
          statements,
        });
      }
    } catch (error) {
      console.error('Failed to generate code:', error);
    }
  };

  // Toolbar action handlers
  const handleAddVariable = () => {
    variableDialogRef.current?.open();
  };

  const handleSaveVariable = (name: string) => {
    if (workspaceRef.current) {
      workspaceRef.current.createVariable(name);
      message.success(`Variable "${name}" created`);
    }
  };

  const handleExportXML = () => {
    if (!workspaceRef.current) return;

    try {
      const xml = Blockly.Xml.workspaceToDom(workspaceRef.current);
      const xmlText = Blockly.Xml.domToText(xml);

      const builder = new XMLBuilder({ format: true });
      const parser = new XMLParser();
      const xmlObj = parser.parse(xmlText);
      const formattedXml = builder.build(xmlObj);

      const blob = new Blob([formattedXml], { type: 'text/xml;charset=utf-8' });
      FileSaver.saveAs(blob, `functional-mapping-${localMapping?.dstPath || 'export'}.xml`);
      message.success('XML exported successfully');
    } catch (error) {
      console.error('Failed to export XML:', error);
      message.error('Failed to export XML');
    }
  };

  const handleImportXML = (file: any) => {
    if (!workspaceRef.current) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const xmlText = e.target?.result as string;
        const dom = Blockly.utils.xml.textToDom(xmlText);
        workspaceRef.current.clear();
        Blockly.Xml.domToWorkspace(dom, workspaceRef.current);
        message.success('XML imported successfully');
      } catch (error) {
        console.error('Failed to import XML:', error);
        message.error('Failed to import XML');
      }
    };
    reader.readAsText(file);
    return false; // Prevent upload
  };

  const handleOpenFunctionDescription = () => {
    functionDescriptionDialogRef.current?.open();
  };

  const handleSearchChange = (value: any) => {
    console.log('Search selected:', value);
    // TODO: Add block to workspace based on selection
    setSearchKey(searchKey + 1);
  };

  const handleRegenerateBlockly = () => {
    if (functionalMapping) {
      loadFunctionalMappingIntoBlockly(functionalMapping);
      setErrorBlocklyNonExistent(false);
      message.success('Blocks regenerated');
    }
  };

  const handleRegenerateBlocklyAll = () => {
    // TODO: Implement regenerate all blocks
    handleRegenerateBlockly();
  };

  const handleSave = async () => {
    try {
      await form.validateFields();

      // Get statements from Blockly
      if (workspaceRef.current && localMapping) {
        const code = (JSONGenerator as any).workspaceToCode(workspaceRef.current);
        if (code) {
          const parsed = JSON.parse(code);
          const statements = clearAutoGeneratedFields(parsed.statements || []);

          const updatedMapping = {
            ...localMapping,
            statements,
          };

          onSave(updatedMapping);
        } else {
          onSave(localMapping);
        }
      } else if (localMapping) {
        onSave(localMapping);
      }
    } catch (error) {
      console.error('Validation failed:', error);
    }
  };

  const handleAddSourcePath = (path: string) => {
    if (localMapping && !localMapping.srcPaths.includes(path)) {
      const updated = {
        ...localMapping,
        srcPaths: [...localMapping.srcPaths, path],
      };
      setLocalMapping(updated);
      form.setFieldsValue({ srcPaths: updated.srcPaths });
    }
  };

  const handleRemoveSourcePath = (path: string) => {
    if (localMapping) {
      const updated = {
        ...localMapping,
        srcPaths: localMapping.srcPaths.filter((p) => p !== path),
      };
      setLocalMapping(updated);
      form.setFieldsValue({ srcPaths: updated.srcPaths });
    }
  };

  const handleAddStatement = () => {
    if (localMapping) {
      const newStatement: any = {
        type: 'RETURN' as const,
        expression: {
          type: 'CONSTANT',
          constantSource: 'INPUT' as const,
          args: [],
        },
        collectElemsSetModes: [],
      };
      const updated = {
        ...localMapping,
        statements: [...localMapping.statements, newStatement],
      };
      setLocalMapping(updated);
    }
  };

  const handleEditStatement = (index: number) => {
    setCurrentStatementIndex(index);
    // Convert statement object to JSON for editing
    const statement = localMapping?.statements[index];
    setCurrentStatementCode(statement ? JSON.stringify(statement, null, 2) : '');
    setCodeEditorVisible(true);
  };

  const handleDeleteStatement = (index: number) => {
    if (localMapping) {
      const updated = {
        ...localMapping,
        statements: localMapping.statements.filter((_, i) => i !== index),
      };
      setLocalMapping(updated);
    }
  };

  const handleSaveCode = (code: string) => {
    if (localMapping && currentStatementIndex >= 0) {
      try {
        const parsed = JSON.parse(code);
        const updated = { ...localMapping };
        updated.statements[currentStatementIndex] = parsed;
        setLocalMapping(updated);
        setCodeEditorVisible(false);
        setCurrentStatementIndex(-1);
      } catch (error) {
        console.error('Invalid JSON:', error);
      }
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (localMapping) {
      setLocalMapping({
        ...localMapping,
        name: e.target.value || null,
      });
    }
  };

  if (!localMapping) return null;

  const getStatementPreview = (statement: any): string => {
    return JSON.stringify(statement, null, 2).substring(0, 100);
  };

  return (
    <>
      <Modal
        title="Functional Mapping Settings"
        open={visible}
        onOk={handleSave}
        onCancel={onCancel}
        width={1200}
        className="functional-mapping-settings-modal"
        style={{ top: 20 }}
      >
        <div className="functional-mapping-settings">
          <Tabs
            activeKey={activeTab}
            onChange={setActiveTab}
            items={[
              {
                key: 'blockly',
                label: (
                  <span>
                    <BlockOutlined /> Visual Editor (Blockly)
                  </span>
                ),
                children: (
                  <div className="blockly-editor-section">
                    <Form form={form} layout="vertical">
                      <Form.Item
                        label="Name"
                        name="name"
                        help={
                          <span style={{ fontSize: '12px', color: '#666' }}>
                            <strong>Note:</strong> If you do not fill this field this field will be generated automatically
                          </span>
                        }
                      >
                        <Input
                          placeholder="Optional name for this mapping"
                          onChange={handleNameChange}
                        />
                      </Form.Item>
                    </Form>

                    <Divider style={{ margin: '12px 0' }} />
                      {errorBlocklyNonExistent ? (
                        <div className="blockly-error-section">
                          <Alert
                            message="Warning"
                            description="Error with Non Existent parameters. Recommended to re-generate this block or all blocks"
                            type="warning"
                            showIcon
                            style={{ marginBottom: 16 }}
                          />
                          <Space>
                            <Button onClick={handleRegenerateBlockly}>
                              <ReloadOutlined /> Regenerate current
                            </Button>
                            <Button onClick={handleRegenerateBlocklyAll}>
                              <ReloadOutlined /> Regenerate all blocks
                            </Button>
                          </Space>
                        </div>
                      ) : (
                        <>
                          <div className="blockly-toolbar">
                            <Space wrap>
                              <FunctionalMappingSearch
                                key={searchKey}
                                listAllFunctions={listAllFunctionsRef.current}
                                listAllTransformers={listAllTransformersRef.current}
                                onChange={handleSearchChange}
                              />
                              <Button type="default" onClick={handleAddVariable} icon={<PlusOutlined />}>
                                Add Variable
                              </Button>
                              <Button type="primary" onClick={handleExportXML} icon={<DownloadOutlined />}>
                                Export XML
                              </Button>
                              <Upload
                                accept=".xml"
                                beforeUpload={handleImportXML}
                                showUploadList={false}
                              >
                                <Button type="default" icon={<UploadOutlined />}>
                                  Import XML
                                </Button>
                              </Upload>
                              <Button type="default" onClick={handleOpenFunctionDescription} icon={<QuestionCircleOutlined />}>
                                Documentation
                              </Button>
                            </Space>
                          </div>
                          <div
                            ref={blocklyDivRef}
                            className="blockly-workspace blocklyDiv"
                            style={{
                              height: '450px',
                              width: '100%',
                              textAlign: 'left'
                            }}
                          />
                          <CodeDisplay code={generatedCode ? JSON.stringify(JSON.parse(generatedCode), null, 2) : ''} />
                        </>
                      )}
                      {isLoadingBlockly && (
                        <div style={{
                          position: 'absolute',
                          top: '50%',
                          left: '50%',
                          transform: 'translate(-50%, -50%)',
                          zIndex: 1000
                        }}>
                          <Alert message="Loading Blockly editor..." type="info" showIcon />
                        </div>
                      )}
                    </div>
                  ),
                },
                {
                  key: 'code',
                  label: (
                    <span>
                      <CodeOutlined /> Generated Code
                    </span>
                  ),
                  children: (
                    <div className="code-preview-section">
                      <Alert
                        message="Generated JSON"
                        description="This code is automatically generated from the Blockly blocks above."
                        type="success"
                        showIcon
                        style={{ marginBottom: 16 }}
                      />
                      <pre style={{
                        background: '#f5f5f5',
                        padding: '16px',
                        borderRadius: '4px',
                        maxHeight: '450px',
                        overflow: 'auto',
                        fontSize: '12px',
                      }}>
                        {generatedCode ? JSON.stringify(JSON.parse(generatedCode), null, 2) : '// No code generated yet'}
                      </pre>
                    </div>
                  ),
                },
                {
                  key: 'manual',
                  label: (
                    <span>
                      <CodeOutlined /> Manual JSON Editor
                    </span>
                  ),
                  children: (
                    <div className="statements-section">
                      {localMapping.statements.length === 0 ? (
                        <Alert
                          message="No statements defined"
                          description="Use the Visual Editor (Blockly) tab to create transformations, or add statements manually here."
                          type="info"
                          showIcon
                          style={{ marginBottom: 16 }}
                        />
                      ) : (
                        <div className="statements-list">
                          {localMapping.statements.map((statement, index) => (
                            <div key={index} className="statement-item">
                              <div className="statement-header">
                                <span className="statement-label">Statement {index + 1}</span>
                                <Space>
                                  <Button
                                    type="text"
                                    icon={<CodeOutlined />}
                                    onClick={() => handleEditStatement(index)}
                                  >
                                    Edit
                                  </Button>
                                  <Button
                                    type="text"
                                    danger
                                    icon={<DeleteOutlined />}
                                    onClick={() => handleDeleteStatement(index)}
                                  >
                                    Delete
                                  </Button>
                                </Space>
                              </div>
                              <pre className="statement-preview">
                                {getStatementPreview(statement)}
                                {JSON.stringify(statement).length > 100 ? '...' : ''}
                              </pre>
                            </div>
                          ))}
                        </div>
                      )}

                      <Button
                        type="primary"
                        icon={<PlusOutlined />}
                        onClick={handleAddStatement}
                        style={{ marginTop: 16 }}
                      >
                        Add Statement
                      </Button>
                    </div>
                  ),
                },
              ]}
            />
          </Form>

          <Divider />

          <Alert
            message="Functional Mapping Info"
            description="Functional mappings allow you to use multiple source paths and custom JavaScript/Groovy code to transform data before mapping it to the target."
            type="info"
            showIcon
          />
        </div>
      </Modal>

      <Modal
        title={`Edit Statement ${currentStatementIndex + 1}`}
        open={codeEditorVisible}
        onOk={() => handleSaveCode(currentStatementCode)}
        onCancel={() => {
          setCodeEditorVisible(false);
          setCurrentStatementIndex(-1);
        }}
        width={1000}
        className="code-editor-modal"
      >
        <Alert
          message="Edit Statement JSON"
          description="Edit the statement configuration as JSON. Make sure the JSON is valid before saving."
          type="info"
          showIcon
          style={{ marginBottom: 16 }}
        />
        <CodeEditor
          value={currentStatementCode}
          onChange={(value) => setCurrentStatementCode(value || '')}
          language="json"
          height="500px"
        />
      </Modal>

      {/* Helper Dialogs */}
      <VariableDialog ref={variableDialogRef} onAdd={handleSaveVariable} />
      <FunctionDescriptionDialog
        ref={functionDescriptionDialogRef}
        listAllFunctions={listAllFunctionsRef.current}
        listAllTransformers={listAllTransformersRef.current}
      />
      <FunctionalMappingDiff ref={functionalMappingDiffRef} />
    </>
  );
};

export default FunctionalMappingSettings;

