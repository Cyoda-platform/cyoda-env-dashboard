import React, { useRef, useEffect, useState, forwardRef, useImperativeHandle } from 'react';
import { Spin } from 'antd';
import * as Blockly from 'blockly/core';
import { XMLBuilder, XMLParser } from 'fast-xml-parser';

// Import Blockly blocks
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/FunctionalMappingConfig';
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/Expresssions';
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementVariables';
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementReturn';
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/StatementSetDstValue';
import '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/Functions';
import GeneratedFunctions from '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedFunctions';
import GeneratedTransformers from '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/blocks/GeneratedTransformers';

// Import generators
import JSONGenerator from '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/generators/json_generator.js';
import BlocklyGenerator from '../../../components/DataMapper/FunctionalMappingSettings/FunctionalMapping/generators/blockly_generator';

// Import types
import type { 
  MappingConfigDto, 
  EntityMappingConfigDto, 
  FunctionalMappingConfigDto 
} from '../../../types';

// Import helpers
import { clearAutoGeneratedFields } from '../../../utils/mapperHelper';
import { useDataMappingApi } from '../../../api/dataMappingApi';

interface FunctionalMappingEditorProps {
  blocklyHeight?: number;
}

export interface FunctionalMappingEditorRef {
  initAllFunctions: () => Promise<void>;
  initListTransformers: () => Promise<void>;
  initListAllDictionaries: () => Promise<void>;
  addBlockly: () => void;
  setContentToBlockly: (
    dataMapping: MappingConfigDto,
    entityMapping: EntityMappingConfigDto,
    functionalMapping: FunctionalMappingConfigDto
  ) => { generatedStatements: any; existStatements: any };
}

const FunctionalMappingEditor = forwardRef<FunctionalMappingEditorRef, FunctionalMappingEditorProps>(
  ({ blocklyHeight = 450 }, ref) => {
    const blocklyDivRef = useRef<HTMLDivElement>(null);
    const workspaceRef = useRef<any>(null);
    const [isLoading, setIsLoading] = useState(false);

    const { getListAllFunctions, getListAllTransformers, getListAllDictionaries } = useDataMappingApi();

    const listAllFunctionsRef = useRef<any[]>([]);
    const listAllTransformersRef = useRef<any[]>([]);
    const listAllDictionariesRef = useRef<any[]>([]);

    const options = {
      grid: {
        spacing: 25,
        length: 3,
        colour: '#ccc',
      },
      zoom: {
        controls: true,
      },
    };

    // Initialize all functions
    const initAllFunctions = async () => {
      const { data } = await getListAllFunctions();
      listAllFunctionsRef.current = data;
      GeneratedFunctions.init(listAllFunctionsRef.current);
    };

    // Initialize transformers
    const initListTransformers = async () => {
      const { data } = await getListAllTransformers();
      listAllTransformersRef.current = data;
      GeneratedTransformers.init(listAllTransformersRef.current, workspaceRef.current);
    };

    // Initialize dictionaries
    const initListAllDictionaries = async () => {
      const { data } = await getListAllDictionaries();
      listAllDictionariesRef.current = data.dictionaries;
    };

    // Add Blockly workspace
    const addBlockly = () => {
      if (blocklyDivRef.current && !workspaceRef.current) {
        (JSONGenerator as any).vue = { functionalMappingConfig: null };
        workspaceRef.current = Blockly.inject(blocklyDivRef.current, options);
      }
    };

    // Get XML for Blockly
    const getXmlForBlockly = (
      dataMapping: MappingConfigDto,
      entityMapping: EntityMappingConfigDto,
      functionalMapping: FunctionalMappingConfigDto
    ): string => {
      const blocklyXml = BlocklyGenerator.generateBlocklyXml(
        dataMapping,
        entityMapping,
        functionalMapping,
        listAllDictionariesRef.current
      );
      const builder = new XMLBuilder({
        ignoreAttributes: false,
        format: true,
      });
      return builder.build(blocklyXml);
    };

    // Set content to Blockly
    const setContentToBlockly = (
      dataMapping: MappingConfigDto,
      entityMapping: EntityMappingConfigDto,
      functionalMapping: FunctionalMappingConfigDto
    ) => {
      if (!workspaceRef.current) return { generatedStatements: null, existStatements: null };

      workspaceRef.current.clear();
      (JSONGenerator as any).vue.functionalMappingConfig = functionalMapping;

      const existStatements = clearAutoGeneratedFields(functionalMapping.statements || []);

      const xmlText = getXmlForBlockly(dataMapping, entityMapping, functionalMapping);
      const dom = Blockly.utils.xml.textToDom(xmlText);
      Blockly.Xml.domToWorkspace(dom, workspaceRef.current);

      let jsonDataGenerated = (JSONGenerator as any).workspaceToCode(workspaceRef.current);

      if (jsonDataGenerated) {
        jsonDataGenerated = JSON.parse(jsonDataGenerated);
      }

      const generatedStatements = clearAutoGeneratedFields(jsonDataGenerated?.statements || []);

      return {
        generatedStatements,
        existStatements,
      };
    };

    // Expose methods via ref
    useImperativeHandle(ref, () => ({
      initAllFunctions,
      initListTransformers,
      initListAllDictionaries,
      addBlockly,
      setContentToBlockly,
    }));

    // Cleanup on unmount
    useEffect(() => {
      return () => {
        if (workspaceRef.current) {
          workspaceRef.current.clear();
          workspaceRef.current = null;
        }
      };
    }, []);

    return (
      <div className="tools-functional-mapping">
        <Spin spinning={isLoading}>
          <div
            ref={blocklyDivRef}
            className="blocklyDiv"
            style={{ height: `${blocklyHeight}px`, display: 'none' }}
          />
        </Spin>
      </div>
    );
  }
);

FunctionalMappingEditor.displayName = 'FunctionalMappingEditor';

export default FunctionalMappingEditor;

